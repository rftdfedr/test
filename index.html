<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Приём космического сигнала</title>
  <style>
    /* Мягкий жёлтый цвет #FFCF40 */
    :root {
      --soft-yellow: #ffcf40;
      --soft-yellow-glow: rgba(255, 207, 64, 0.7);
      --creepy-red: #ff3300;
      --creepy-red-glow: rgba(255, 51, 0, 0.8);
      --dark-bg: #000000;
      --dark-bg-2: #331f00;
      --dark-border: #664d00;
    }

    /* Общие настройки */
    body {
      margin: 0;
      background: var(--dark-bg);
      color: var(--soft-yellow);
      font-family: 'Courier New', Courier, monospace;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
      position: relative;
    }

    /* Левая панель */
    #left-panel {
      width: 100%;
      background: var(--dark-bg);
      display: flex;
      flex-direction: column;
      border-bottom: 2px solid var(--soft-yellow);
      box-sizing: border-box;
      max-height: 50vh;
    }

    /* Вкладки */
    .tabs {
      display: flex;
      background: var(--dark-bg);
      border-bottom: 2px solid var(--soft-yellow);
    }
    .tab {
      flex: 1;
      padding: 12px 0;
      text-align: center;
      cursor: pointer;
      color: var(--soft-yellow);
      user-select: none;
      border-bottom: 3px solid transparent;
      transition: border-color 0.3s;
      text-shadow:
        0 0 5px var(--soft-yellow-glow),
        0 0 10px var(--soft-yellow-glow),
        0 0 20px var(--soft-yellow-glow);
      position: relative;
      font-size: 14px;
    }
    .tab.active {
      border-bottom-color: #ffd85c;
      font-weight: bold;
      color: #ffd85c;
      text-shadow:
        0 0 10px #ffd85c,
        0 0 20px #ffd85c,
        0 0 30px #ffd85c;
    }
    /* Значок на вкладке */
    .tab .badge {
      position: absolute;
      top: 6px;
      right: 12px;
      font-weight: bold;
      color: var(--soft-yellow);
      user-select: none;
      pointer-events: none;
      font-size: 18px;
      line-height: 1;
    }

    /* Контент вкладок */
    .tab-content {
      flex: 1;
      padding: 15px;
      overflow-y: auto;
      background: var(--dark-bg);
      box-shadow:
        inset 0 0 40px var(--soft-yellow-glow);
      display: flex;
      flex-direction: column;
    }

    /* Кнопки */
    button {
      font-family: 'Courier New', Courier, monospace;
      font-size: 16px;
      background: transparent;
      border: 2px solid var(--soft-yellow);
      color: var(--soft-yellow);
      padding: 12px 20px;
      cursor: pointer;
      border-radius: 0;
      text-shadow:
        0 0 5px var(--soft-yellow-glow),
        0 0 10px var(--soft-yellow-glow);
      transition: background-color 0.3s, color 0.3s;
      align-self: flex-start;
    }
    button:hover:not(:disabled) {
      background-color: #ffd85c;
      color: #000000;
      text-shadow: none;
    }
    button:disabled {
      border-color: var(--dark-border);
      color: var(--dark-border);
      cursor: default;
      text-shadow: none;
    }

    /* Контейнер для кнопки и переключателя */
    .controls-row {
      display: flex;
      flex-direction: column;
      gap: 15px;
      margin-top: 15px;
    }

    /* Переключатель фильтра */
    .filter-container {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 15px;
      border: 2px solid var(--soft-yellow);
      background: transparent;
    }
    .switch {
      position: relative;
      display: inline-block;
      width: 50px;
      height: 24px;
    }
    .switch input {
      opacity: 0;
      width: 0;
      height: 0;
    }
    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: var(--dark-border);
      transition: .4s;
      border: 1px solid var(--soft-yellow);
    }
    .slider:before {
      position: absolute;
      content: "";
      height: 16px;
      width: 16px;
      left: 4px;
      bottom: 3px;
      background-color: var(--soft-yellow);
      transition: .4s;
    }
    input:checked + .slider {
      background-color: var(--soft-yellow);
    }
    input:checked + .slider:before {
      background-color: var(--dark-bg);
      transform: translateX(26px);
    }
    .filter-label {
      font-size: 14px;
      color: var(--soft-yellow);
      text-shadow: 0 0 5px var(--soft-yellow-glow);
      white-space: nowrap;
    }
    .filter-status {
      font-size: 12px;
      color: var(--soft-yellow);
      margin-top: 4px;
    }
    .filter-status.active {
      color: #ffd85c;
      font-weight: bold;
      text-shadow: 0 0 10px #ffd85c;
    }

    /* Таблица радиотелескопов */
    table {
      width: 100%;
      border-collapse: collapse;
      color: var(--soft-yellow);
      text-shadow:
        0 0 5px var(--soft-yellow-glow);
      margin-top: 10px;
    }
    th, td {
      padding: 8px 6px;
      border-bottom: 1px solid var(--dark-border);
      text-align: left;
      font-size: 12px;
    }
    th {
      background: var(--dark-bg-2);
    }
    .status-online {
      color: #ffd85c;
      font-weight: bold;
      text-shadow:
        0 0 10px #ffd85c;
    }
    .status-offline {
      color: var(--creepy-red);
      font-weight: bold;
      text-shadow:
        0 0 15px var(--creepy-red-glow),
        0 0 30px var(--creepy-red-glow);
    }
    .connection-good {
      color: var(--soft-yellow);
    }
    .connection-bad {
      color: var(--creepy-red);
      font-weight: bold;
    }
    .reconnect-btn {
      background: transparent;
      border: 1px solid var(--soft-yellow);
      color: var(--soft-yellow);
      padding: 6px 12px;
      font-family: 'Courier New', Courier, monospace;
      font-size: 11px;
      cursor: pointer;
      text-shadow:
        0 0 5px var(--soft-yellow-glow);
      transition: background-color 0.3s, color 0.3s;
      border-radius: 0;
    }
    .reconnect-btn:hover:not(:disabled) {
      background-color: #ffd85c;
      color: #000000;
      text-shadow: none;
    }
    .reconnect-btn:disabled {
      border-color: var(--dark-border);
      color: var(--dark-border);
      cursor: default;
      text-shadow: none;
    }

    /* Кастомный список истории сигналов */
    #history-list {
      width: 100%;
      height: 200px;
      background: transparent;
      border: 2px solid transparent;
      border-radius: 3px;
      color: var(--soft-yellow);
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
      overflow-y: auto;
      padding: 8px;
      box-sizing: border-box;
      margin-bottom: 10px;
      text-shadow:
        0 0 5px var(--soft-yellow-glow);
      outline: none;
      user-select: none;
    }
    #history-list:focus {
      border-color: transparent;
      background-color: transparent;
      color: var(--soft-yellow);
    }
    #history-list .option {
      padding: 6px 8px;
      cursor: pointer;
      border-radius: 3px;
      margin-bottom: 2px;
      transition: background-color 0.3s, color 0.3s;
      user-select: none;
    }
    #history-list .option:hover {
      background-color: var(--soft-yellow);
      color: #000000;
    }
    #history-list .option.selected {
      background-color: var(--soft-yellow);
      color: #000000;
      font-weight: bold;
      text-shadow: none;
    }

    /* Правая консоль */
    #right-panel {
      flex: 1;
      background: var(--dark-bg);
      display: flex;
      flex-direction: column;
      padding: 15px;
      color: var(--soft-yellow);
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
      box-shadow:
        inset 0 0 50px var(--soft-yellow-glow);
      position: relative;
      overflow: hidden;
    }
    textarea {
      background: var(--dark-bg);
      border: none;
      color: var(--soft-yellow);
      resize: none;
      overflow-y: auto;
      margin-bottom: 10px;
      font-size: 14px;
      font-family: 'Courier New', Courier, monospace;
      padding: 8px;
      border-radius: 0;
      text-shadow:
        0 0 5px var(--soft-yellow-glow),
        0 0 15px var(--soft-yellow-glow);
      position: relative;
      z-index: 2;
    }
    #status-text {
      height: 40px;
      overflow-y: hidden;
    }
    #binary-text {
      height: 120px;
    }
    #result-text {
      height: 200px;
    }
    .creepy {
      color: var(--creepy-red);
      font-weight: bold;
      text-shadow:
        0 0 15px var(--creepy-red-glow),
        0 0 30px var(--creepy-red-glow),
        0 0 45px var(--creepy-red-glow);
    }

    /* Кнопка расшифровки */
    #decrypt-btn {
      align-self: center;
      margin: 10px 0;
      width: 100%;
    }

    /* Усиленный глич эффект (искажение кадра) */
    #right-panel::before {
      content: "";
      pointer-events: none;
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      background:
        repeating-linear-gradient(
          0deg,
          rgba(255, 207, 64, 0.12),
          rgba(255, 207, 64, 0.12) 2px,
          transparent 3px,
          transparent 4px
        ),
        repeating-linear-gradient(
          90deg,
          rgba(255, 207, 64, 0.06),
          rgba(255, 207, 64, 0.06) 1px,
          transparent 2px,
          transparent 3px
        );
      mix-blend-mode: screen;
      animation: glitchShift 0.25s infinite alternate;
      z-index: 1;
      filter: contrast(1.3) brightness(1.15);
    }

    @keyframes glitchShift {
      0% {
        transform: translate(0, 0);
        opacity: 0.95;
      }
      50% {
        transform: translate(3px, -3px);
        opacity: 0.75;
      }
      100% {
        transform: translate(-3px, 3px);
        opacity: 0.95;
      }
    }

    /* Мерцание текста */
    @keyframes flicker {
      0%, 19%, 21%, 23%, 25%, 54%, 56%, 100% {
        opacity: 1;
      }
      20%, 22%, 24%, 55% {
        opacity: 0.4;
      }
    }
    #right-panel textarea {
      animation: flicker 3s infinite;
    }

    /* Курсор мерцающий */
    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }
    .cursor {
      display: inline-block;
      width: 8px;
      background: var(--soft-yellow);
      margin-left: 2px;
      animation: blink 1s step-start infinite;
    }

    /* Стиль для индикатора загрузки */
    .loading {
      color: var(--soft-yellow);
      text-align: center;
      padding: 20px;
    }

    /* Сцена стола */
    #desk-scene {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(to bottom, #1a0f00 0%, #0a0600 100%);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      overflow: hidden;
    }

    /* Деревянный стол */
    .desk {
      width: 90%;
      height: 60%;
      background: linear-gradient(to bottom, #3d2a14 0%, #2b1d0c 100%);
      border: 15px solid #1a1005;
      border-radius: 10px;
      position: relative;
      box-shadow: 
        0 0 50px rgba(0, 0, 0, 0.8),
        inset 0 0 30px rgba(0, 0, 0, 0.5);
      transform-style: preserve-3d;
      perspective: 1000px;
    }

    /* Листок бумаги */
    .paper {
      position: absolute;
      width: 300px;
      height: 400px;
      background: #f5f0e6;
      border: 1px solid #d4c9b8;
      box-shadow: 
        0 0 20px rgba(0, 0, 0, 0.3),
        0 0 10px rgba(255, 207, 64, 0.1);
      cursor: grab;
      transform-origin: center;
      transition: box-shadow 0.3s;
      padding: 20px;
      font-family: 'Courier New', monospace;
      color: #3a2c1a;
      font-size: 14px;
      line-height: 1.4;
      overflow: hidden;
      user-select: none;
    }

    .paper:active {
      cursor: grabbing;
      box-shadow: 
        0 0 25px rgba(0, 0, 0, 0.4),
        0 0 15px rgba(255, 207, 64, 0.2);
    }

    .paper-texture {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: 
        radial-gradient(circle at 10% 20%, rgba(0,0,0,0.03) 1px, transparent 1px),
        radial-gradient(circle at 80% 60%, rgba(0,0,0,0.03) 1px, transparent 1px);
      background-size: 30px 30px, 40px 40px;
      opacity: 0.6;
      pointer-events: none;
    }

    /* Подсказки управления */
    .controls-hint {
      position: absolute;
      bottom: 20px;
      left: 0;
      width: 100%;
      text-align: center;
      color: var(--soft-yellow);
      font-size: 14px;
      text-shadow: 0 0 10px var(--soft-yellow-glow);
      z-index: 1001;
      background: rgba(0, 0, 0, 0.5);
      padding: 10px;
    }

    /* Анимации переходов */
    .transition-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: black;
      z-index: 2000;
      display: none;
      align-items: center;
      justify-content: center;
      color: var(--soft-yellow);
      font-size: 24px;
      text-shadow: 0 0 10px var(--soft-yellow-glow);
    }

    .eye-close {
      animation: eyeClose 2s ease-in-out;
    }

    .eye-open {
      animation: eyeOpen 2s ease-in-out;
    }

    @keyframes eyeClose {
      0% {
        opacity: 0;
        filter: blur(0px);
      }
      30% {
        opacity: 1;
        filter: blur(0px);
      }
      70% {
        opacity: 1;
        filter: blur(10px);
      }
      100% {
        opacity: 0;
        filter: blur(20px);
      }
    }

    @keyframes eyeOpen {
      0% {
        opacity: 0;
        filter: blur(20px);
      }
      30% {
        opacity: 1;
        filter: blur(10px);
      }
      70% {
        opacity: 1;
        filter: blur(0px);
      }
      100% {
        opacity: 0;
        filter: blur(0px);
      }
    }

    .screen-move-up {
      animation: screenMoveUp 1.5s ease-in-out;
    }

    .screen-move-down {
      animation: screenMoveDown 1.5s ease-in-out;
    }

    .desk-move-down {
      animation: deskMoveDown 1.5s ease-in-out;
    }

    .desk-move-up {
      animation: deskMoveUp 1.5s ease-in-out;
    }

    @keyframes screenMoveUp {
      0% {
        transform: translateY(0);
        opacity: 1;
      }
      50% {
        transform: translateY(-25%);
        opacity: 0.5;
      }
      100% {
        transform: translateY(-100%);
        opacity: 0;
      }
    }

    @keyframes screenMoveDown {
      0% {
        transform: translateY(-100%);
        opacity: 0;
      }
      50% {
        transform: translateY(-25%);
        opacity: 0.5;
      }
      100% {
        transform: translateY(0);
        opacity: 1;
      }
    }

    @keyframes deskMoveDown {
      0% {
        transform: translateY(0);
        opacity: 1;
      }
      50% {
        transform: translateY(25%);
        opacity: 0.5;
      }
      100% {
        transform: translateY(100%);
        opacity: 0;
      }
    }

    @keyframes deskMoveUp {
      0% {
        transform: translateY(100%);
        opacity: 0;
      }
      50% {
        transform: translateY(25%);
        opacity: 0.5;
      }
      100% {
        transform: translateY(0);
        opacity: 1;
      }
    }

    /* Медиа-запросы для адаптации под разные экраны */
    @media (min-width: 768px) {
      body {
        flex-direction: row;
      }
      
      #left-panel {
        width: 50%;
        max-height: 100vh;
        border-right: 2px solid var(--soft-yellow);
        border-bottom: none;
      }
      
      .controls-row {
        flex-direction: row;
      }
      
      #decrypt-btn {
        width: 200px;
      }
      
      #binary-text {
        height: 140px;
      }
      
      #result-text {
        height: 350px;
      }
      
      #history-list {
        height: 300px;
      }
      
      th, td {
        font-size: 14px;
        padding: 10px 8px;
      }
      
      .tab {
        font-size: 16px;
      }
    }

    @media (min-width: 1024px) {
      #left-panel {
        width: 700px;
      }
    }
  </style>
</head>
<body>
  <!-- Основной интерфейс компьютера -->
  <div id="left-panel">
    <div class="tabs">
      <div class="tab active" data-tab="signals">Сигналы</div>
      <div class="tab" data-tab="telescopes">Радиотелескопы</div>
      <div class="tab" data-tab="history">История сигналов</div>
    </div>
    <div id="signals" class="tab-content">
      <div style="font-size: 18px; margin-bottom: 10px;">Готов принять сигнал?</div>
      
      <div class="controls-row">
        <button id="receive-btn" disabled>Загрузка сигналов...</button>
        
        <div class="filter-container">
          <div class="filter-label">Фильтр частот</div>
          <label class="switch">
            <input type="checkbox" id="filter-toggle">
            <span class="slider"></span>
          </label>
          <div class="filter-status" id="filter-status">ВЫКЛ</div>
        </div>
      </div>
      
      <div id="loading-status" class="loading"></div>
    </div>
    <div id="telescopes" class="tab-content" style="display:none;">
      <table>
        <thead>
          <tr>
            <th>Название</th>
            <th>Статус</th>
            <th>Соединение</th>
            <th>Действия</th>
          </tr>
        </thead>
        <tbody id="telescopes-body"></tbody>
      </table>
    </div>
    <div id="history" class="tab-content" style="display:none; flex-direction: column;">
      <div id="history-list" tabindex="0"></div>
      <button id="delete-button">Удалить выбранный</button>
    </div>
  </div>
  <div id="right-panel">
    <textarea id="status-text" readonly></textarea>
    <textarea id="binary-text" readonly></textarea>
    <button id="decrypt-btn" disabled>Расшифровать</button>
    <textarea id="result-text" readonly></textarea>
  </div>

  <!-- Сцена стола -->
  <div id="desk-scene">
    <div class="desk">
      <div class="paper">
        <div class="paper-texture"></div>
        <h3 style="text-align: center; margin-bottom: 15px; border-bottom: 1px solid #d4c9b8; padding-bottom: 10px;">
          ЗАПИСИ О СИГНАЛАХ
        </h3>
        <div id="paper-content">
          <p><strong>Дата:</strong> <span id="paper-date"></span></p>
          <p><strong>Сигнал:</strong> <span id="paper-signal-type"></span></p>
          <div id="paper-message" style="margin-top: 15px; font-style: italic; min-height: 200px;">
            Здесь будет отображаться содержимое выбранного сигнала...
          </div>
          <div style="margin-top: 20px; font-size: 12px; color: #7a6a51;">
            <p>/// СИСТЕМНЫЕ ЗАМЕТКИ ///</p>
            <p>Аномальные сигналы требуют особого внимания.</p>
            <p>Проверять историю приёма каждые 24 часа.</p>
          </div>
        </div>
      </div>
    </div>
    <div class="controls-hint">
      Перемещайте листок мышью • Вращайте с зажатым Shift • Нажмите ↑ для возврата к компьютеру
    </div>
  </div>

  <!-- Оверлей перехода -->
  <div id="transition-overlay" class="transition-overlay"></div>

  <script>
    // Флаг блокировки переподключения
    let reconnectInProgress = new Set();

    // Звуки
    const ambientAudio = new Audio('sound/ambient.mp3');
    ambientAudio.loop = true;
    ambientAudio.volume = 0.30;

    const priemAudio = new Audio('sound/priem-obrabotra.mp3');
    priemAudio.volume = 0.5;

    const radiooffAudio = new Audio('sound/radiooff.mp3');
    radiooffAudio.volume = 0.5;

    // Звуки расшифровки
    const decryptAudio1 = new Audio('sound/random_dechifrator_1.mp3');
    const decryptAudio2 = new Audio('sound/random_dechifrator_2.mp3');
    decryptAudio1.volume = 0.5;
    decryptAudio2.volume = 0.5;

    // Звук перехода
    const transitionAudio = new Audio('sound/transition.mp3');
    transitionAudio.volume = 0.6;

    // Данные сигналов (будут загружены из файлов)
    let NORMAL_SIGNALS = [];
    let CREEPY_SIGNALS = [];

    // Радиотелескопы
    const TELESCOPES = [
      {name: "РАТАН-600 (САО РАН)", status: "online", connection: "Хорошее"},
      {name: "РТ-70 (Пущино)", status: "online", connection: "Хорошее"},
      {name: "Радиотелескоп Звезда (Калязин)", status: "online", connection: "Хорошее"},
      {name: "Радиотелескоп Квазар-КВО (Крым)", status: "online", connection: "Хорошее"}
    ];

    // Элементы
    const tabs = document.querySelectorAll('.tab');
    const tabContents = document.querySelectorAll('.tab-content');
    const receiveBtn = document.getElementById('receive-btn');
    const statusText = document.getElementById('status-text');
    const binaryText = document.getElementById('binary-text');
    const resultText = document.getElementById('result-text');
    const telescopesBody = document.getElementById('telescopes-body');
    const historyList = document.getElementById('history-list');
    const deleteButton = document.getElementById('delete-button');
    const loadingStatus = document.getElementById('loading-status');
    const decryptBtn = document.getElementById('decrypt-btn');
    const filterToggle = document.getElementById('filter-toggle');
    const filterStatus = document.getElementById('filter-status');

    // Элементы сцены стола
    const deskScene = document.getElementById('desk-scene');
    const paper = document.querySelector('.paper');
    const transitionOverlay = document.getElementById('transition-overlay');
    const paperDate = document.getElementById('paper-date');
    const paperSignalType = document.getElementById('paper-signal-type');
    const paperMessage = document.getElementById('paper-message');

    // История сигналов
    let signalHistory = [];
    let creepyActive = false;
    let currentBinarySignal = '';
    let currentResultSignal = '';
    let currentDecryptAudio = null;

    // Отслеживание использованных сигналов
    let usedNormalSignals = new Set();
    let usedCreepySignals = new Set();

    // Флаг для отслеживания процесса расшифровки
    let isDecrypting = false;

    // Переменные для управления листком
    let isDragging = false;
    let startX, startY;
    let initialX, initialY;
    let rotationX = 0;
    let rotationY = 0;
    let isRotating = false;

    // Функция для получения случайного неповторяющегося сигнала
    function getRandomSignal(signalArray, usedSet) {
        // Если фильтр выключен, возвращаем любой случайный сигнал
        if (!filterToggle.checked) {
            return signalArray[Math.floor(Math.random() * signalArray.length)];
        }
        
        // Если все сигналы использованы, сбрасываем счётчик
        if (usedSet.size >= signalArray.length) {
            usedSet.clear();
        }
        
        let availableSignals = signalArray.filter((_, index) => !usedSet.has(index));
        
        if (availableSignals.length === 0) {
            // Если почему-то нет доступных сигналов, сбрасываем и используем любой
            usedSet.clear();
            availableSignals = [...signalArray];
        }
        
        const randomIndex = Math.floor(Math.random() * availableSignals.length);
        const signalIndex = signalArray.indexOf(availableSignals[randomIndex]);
        
        usedSet.add(signalIndex);
        return availableSignals[randomIndex];
    }

    // Функция загрузки файлов
    async function loadSignals() {
      try {
        loadingStatus.textContent = 'Загрузка нормальных сигналов...';
        
        // Загрузка normal_signals.txt
        const normalResponse = await fetch('normal_signals.txt');
        if (!normalResponse.ok) throw new Error('Не удалось загрузить normal_signals.txt');
        const normalText = await normalResponse.text();
        NORMAL_SIGNALS = normalText.split('\n')
          .map(line => line.trim())
          .filter(line => line.length > 0);

        loadingStatus.textContent = 'Загрузка аномальных сигналов...';
        
        // Загрузка creepy_signals.txt
        const creepyResponse = await fetch('creepy_signals.txt');
        if (!creepyResponse.ok) throw new Error('Не удалось загрузить creepy_signals.txt');
        const creepyText = await creepyResponse.text();
        CREEPY_SIGNALS = creepyText.split('\n')
          .map(line => line.trim())
          .filter(line => line.length > 0);

        // Проверяем, что файлы не пустые
        if (NORMAL_SIGNALS.length === 0) throw new Error('Файл normal_signals.txt пуст');
        if (CREEPY_SIGNALS.length === 0) throw new Error('Файл creepy_signals.txt пуст');

        // Вместо информации о количестве сигналов просто очищаем статус загрузки
        loadingStatus.textContent = '';
        receiveBtn.disabled = false;
        receiveBtn.textContent = 'Принять сигнал';
        
        // Устанавливаем статус "Система готова к работе" в верхней консоли
        statusText.value = 'Система готова к работе.';
        
        console.log('Нормальные сигналы:', NORMAL_SIGNALS);
        console.log('Аномальные сигналы:', CREEPY_SIGNALS);

      } catch (error) {
        console.error('Ошибка загрузки сигналов:', error);
        loadingStatus.textContent = `Ошибка загрузки: ${error.message}`;
        loadingStatus.style.color = 'var(--creepy-red)';
        
        // Используем резервные данные если файлы не загрузились
        NORMAL_SIGNALS = ["Резервный нормальный сигнал: система работает в штатном режиме"];
        CREEPY_SIGNALS = ["Резервный аномальный сигнал: ОШИБКА СИСТЕМЫ"];
        receiveBtn.disabled = false;
        receiveBtn.textContent = 'Принять сигнал (резервный режим)';
        statusText.value = 'Система готова к работе. (резервный режим)';
      }
    }

    // Обработчик переключателя фильтра
    filterToggle.addEventListener('change', function() {
        if (this.checked) {
            filterStatus.textContent = 'ВКЛ';
            filterStatus.classList.add('active');
            statusText.value = 'Фильтр активирован. Повторяющиеся частоты блокируются.';
        } else {
            filterStatus.textContent = 'ВЫКЛ';
            filterStatus.classList.remove('active');
            statusText.value = 'Фильтр деактивирован. Все частоты доступны.';
        }
    });

    // Эффект Залго (упрощённый)
    function zalgo(text, intensity=5) {
      const zalgoChars = [
        '\u030d','\u030e','\u0304','\u0305','\u033f','\u0311','\u0306','\u0310',
        '\u0352','\u0357','\u0351','\u0307','\u0308','\u030a','\u0342','\u0343',
        '\u0344','\u034a','\u034b','\u034c','\u0303','\u0302','\u030c','\u0350',
        '\u0300','\u0301','\u030b','\u030f','\u0312','\u0313','\u0314','\u033d',
        '\u0309','\u0363','\u0364','\u0365','\u0366','\u0367','\u0368','\u0369',
        '\u036a','\u036b','\u036c','\u036d','\u036e','\u036f','\u033e','\u035b',
        '\u0346','\u031a'
      ];
      let result = '';
      for (let c of text) {
        result += c;
        if (/[a-zA-Z0-9:. ]/.test(c)) {
          let count = Math.floor(Math.random() * intensity);
          for (let i=0; i<count; i++) {
            result += zalgoChars[Math.floor(Math.random() * zalgoChars.length)];
          }
        }
      }
      return result;
    }

    // Переключение вкладок
    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        tabs.forEach(t => t.classList.remove('active'));
        tab.classList.add('active');
        const target = tab.dataset.tab;
        tabContents.forEach(tc => {
          tc.style.display = (tc.id === target) ? 'flex' : 'none';
        });
      });
    });

    // Обновление значка на вкладке "Радиотелескопы"
    function updateTelescopeTabBadge() {
      const tab = document.querySelector('.tab[data-tab="telescopes"]');
      const hasBroken = TELESCOPES.some(t => t.status === 'offline');
      if (hasBroken) {
        if (!tab.querySelector('.badge')) {
          const badge = document.createElement('span');
          badge.className = 'badge';
          badge.textContent = '●';
          tab.appendChild(badge);
        }
      } else {
        const badge = tab.querySelector('.badge');
        if (badge) badge.remove();
      }
    }

    // Заполнение таблицы радиотелескопов
    function renderTelescopes() {
      telescopesBody.innerHTML = '';
      TELESCOPES.forEach((t, i) => {
        const tr = document.createElement('tr');

        const tdName = document.createElement('td');
        tdName.textContent = t.name;
        tr.appendChild(tdName);

        const tdStatus = document.createElement('td');
        tdStatus.textContent = t.status === 'online' ? 'Онлайн' : 'Оффлайн';
        tdStatus.className = t.status === 'online' ? 'status-online' : 'status-offline';
        tr.appendChild(tdStatus);

        const tdConn = document.createElement('td');
        tdConn.textContent = t.connection;
        tdConn.className = t.connection === 'Хорошее' ? 'connection-good' : 'connection-bad';
        tr.appendChild(tdConn);

        const tdAction = document.createElement('td');
        const btn = document.createElement('button');
        btn.textContent = 'Переподключить';
        btn.className = 'reconnect-btn';
        btn.disabled = t.status === 'online' || reconnectInProgress.has(i);
        btn.addEventListener('click', () => reconnectTelescope(i));
        tdAction.appendChild(btn);
        tr.appendChild(tdAction);

        telescopesBody.appendChild(tr);
      });
      updateTelescopeTabBadge();
    }

    // Обновление статуса кнопки "Принять сигнал"
    function updateReceiveButton() {
      const allOnline = TELESCOPES.every(t => t.status === 'online');
      const signalsLoaded = NORMAL_SIGNALS.length > 0 && CREEPY_SIGNALS.length > 0;
      receiveBtn.disabled = !allOnline || !signalsLoaded || isDecrypting;
    }

    // Анимация "загрузка" с точками
    function animateStatusLoading(baseMessage, duration = 3000) {
      let dots = 0;
      statusText.value = baseMessage;
      return new Promise(resolve => {
        const interval = setInterval(() => {
          dots = (dots + 1) % 6;
          statusText.value = baseMessage + '.'.repeat(dots);
        }, 400);
        setTimeout(() => {
          clearInterval(interval);
          resolve();
        }, duration);
      });
    }

    // Анимация текста по символам с задержкой (эффект печати)
    function animateText(element, text, creepy = false) {
      return new Promise(resolve => {
        element.value = '';
        let i = 0;
        const lines = text.split('\\n'); // Разделяем по \n
        let currentLine = 0;
        let currentChar = 0;
        
        function step() {
          if (currentLine >= lines.length) {
            resolve();
            return;
          }
          
          if (currentChar < lines[currentLine].length) {
            // Добавляем символ к текущей строке
            element.value += lines[currentLine][currentChar];
            currentChar++;
          } else {
            // Переходим на новую строку
            element.value += '\n';
            currentLine++;
            currentChar = 0;
          }
          
          if (creepy) {
            element.style.color = 'var(--creepy-red)';
          } else {
            element.style.color = 'var(--soft-yellow)';
          }
          element.scrollTop = element.scrollHeight;
          
          setTimeout(step, 10); // Увеличил скорость для ASCII-артов
        }
        
        step();
      });
    }

    // Анимация бинарного сигнала с шумом (добавление случайных символов после битов)
    function animateBinaryWithNoise(element, binaryStr) {
      return new Promise(resolve => {
        element.value = '';
        let i = 0;
        const noiseChars = ['|', '-', '~', '*'];
        function step() {
          if (i >= binaryStr.length) {
            resolve();
            return;
          }
          element.value += binaryStr[i];
          // С вероятностью 50% добавляем шум
          if (Math.random() < 0.5) {
            element.value += noiseChars[Math.floor(Math.random() * noiseChars.length)];
          }
          element.scrollTop = element.scrollHeight;
          i++;
          setTimeout(step, 30);
        }
        step();
      });
    }

    // Очистка бинарного кода от шумов
    function cleanBinaryFromNoise(element, binaryStr) {
      return new Promise(resolve => {
        let i = 0;
        const cleanBinary = binaryStr.replace(/[^01]/g, ''); // Убираем все символы кроме 0 и 1
        
        function step() {
          if (i >= cleanBinary.length) {
            resolve();
            return;
          }
          // Заменяем текущий символ на чистый
          const currentText = element.value;
          const newText = cleanBinary.substring(0, i + 1);
          element.value = newText;
          element.scrollTop = element.scrollHeight;
          i++;
          setTimeout(step, 20);
        }
        step();
      });
    }

    // Анимация починки телескопа
    function animateConnectionLoading(telescopeIndex) {
      const frames = [
        "░ ░ ░ ░",
        "▓ ░ ░ ░",
        "▓ ▓ ░ ░",
        "▓ ▓ ▓ ░",
        "▓ ▓ ▓ ▓"
      ];
      const telescope = TELESCOPES[telescopeIndex];
      let repeatCount = Math.floor(Math.random() * 3) + 1; // от 1 до 3 повторов
      let frameIndex = 0;
      let repeatsDone = 0;

      return new Promise(resolve => {
        function nextFrame() {
          telescope.connection = frames[frameIndex];
          renderTelescopes();
          frameIndex++;
          if (frameIndex >= frames.length) {
            frameIndex = 0;
            repeatsDone++;
          }
          if (repeatsDone < repeatCount) {
            setTimeout(nextFrame, 1000); // 1 секунда между кадрами
          } else {
            // Завершение анимации — восстановление соединения
            telescope.status = "online";
            telescope.connection = "Хорошее";
            renderTelescopes();
            updateReceiveButton();
            statusText.value = "Соединение восстановлено.";
            resolve();
          }
        }
        nextFrame();
      });
    }

    // Функция переподключения телескопа с блокировкой повторного запуска
    async function reconnectTelescope(index) {
      if (reconnectInProgress.has(index)) return;
      reconnectInProgress.add(index);

      const telescope = TELESCOPES[index];
      if (telescope.status === "online") {
        reconnectInProgress.delete(index);
        return;
      }
      telescope.connection = "Переподключение...";
      renderTelescopes();
      updateReceiveButton();

      await animateConnectionLoading(index);

      reconnectInProgress.delete(index);
    }

    // Запуск ambient.mp3 при первом клике
    let ambientStarted = false;
    function startAmbient() {
      if (!ambientStarted) {
        ambientAudio.play().then(() => {
          ambientStarted = true;
        }).catch((e) => {
          console.log('Ошибка воспроизведения ambient.mp3:', e);
        });
      }
    }

    // Поломка случайного телескопа
    function breakRandomTelescope() {
      const onlineTelescopes = TELESCOPES.filter(t => t.status === 'online');
      if (onlineTelescopes.length === 0) return;
      const broken = onlineTelescopes[Math.floor(Math.random() * onlineTelescopes.length)];
      broken.status = 'offline';
      broken.connection = 'Нет связи';
      renderTelescopes();
      updateReceiveButton(); // ДОБАВЛЕНО: обновляем состояние кнопки
      radiooffAudio.currentTime = 0;
      radiooffAudio.play();
    }

    // Процесс расшифровки сигнала
    async function decryptSignal() {
      isDecrypting = true;
      updateReceiveButton();
      decryptBtn.disabled = true;
      
      // Выбираем случайный звук расшифровки
      currentDecryptAudio = Math.random() < 0.5 ? decryptAudio1 : decryptAudio2;
      currentDecryptAudio.currentTime = 0;
      currentDecryptAudio.play();
      
      // Анимация точек во время очистки от шумов
      statusText.value = 'Очистка сигнала от шумов';
      await animateStatusLoading('Очистка сигнала от шумов', 2000);

      // Очищаем бинарный код от шумов
      await cleanBinaryFromNoise(binaryText, binaryText.value);

      // Анимация точек во время декодирования
      statusText.value = 'Декодирование сигнала';
      await animateStatusLoading('Декодирование сигнала', 2000);
      
      // Останавливаем звук расшифровки перед выводом результата
      currentDecryptAudio.pause();
      currentDecryptAudio.currentTime = 0;
      
      // Выводим результат
      await animateText(resultText, currentResultSignal, creepyActive);

      // Завершение расшифровки
      if (creepyActive) {
        statusText.value = 'Расшифровка завершена. Обнаружена аномалия.';
        breakRandomTelescope();
      } else {
        statusText.value = 'Расшифровка завершена.';
      }

      // Добавляем в историю
      addSignalToHistory(currentBinarySignal, currentResultSignal, creepyActive);
      
      // Обновляем состояние кнопок
      isDecrypting = false;
      updateReceiveButton();
    }

    // Приём сигнала
    async function receiveSignal() {
      // В начале функции проверяем, все ли телескопы онлайн
      const allOnline = TELESCOPES.every(t => t.status === 'online');
      if (!allOnline) {
        statusText.value = 'Ошибка: не все телескопы онлайн';
        return;
      }

      // Проверяем, что сигналы загружены
      if (NORMAL_SIGNALS.length === 0 || CREEPY_SIGNALS.length === 0) {
        statusText.value = 'Ошибка: сигналы не загружены';
        return;
      }

      receiveBtn.disabled = true;
      decryptBtn.disabled = true;
      binaryText.value = '';
      resultText.value = '';
      statusText.value = '';

      priemAudio.currentTime = 0;
      priemAudio.play();

      // Генерируем сигнал
      currentBinarySignal = Array.from({length: 100}, () => Math.random() < 0.5 ? '0' : '1').join('');
      
      creepyActive = Math.random() < 0.3;
      
      // Используем неповторяющиеся сигналы
      currentResultSignal = creepyActive
        ? getRandomSignal(CREEPY_SIGNALS, usedCreepySignals)
        : getRandomSignal(NORMAL_SIGNALS, usedNormalSignals);

      // Получение сигнала с шумом
      await Promise.all([
        animateStatusLoading('Получение сигнала'),
        animateBinaryWithNoise(binaryText, currentBinarySignal)
      ]);

      priemAudio.pause();

      // Активируем кнопку расшифровки
      statusText.value = 'Сигнал получен. Ожидание расшифровки.';
      decryptBtn.disabled = false;
      
      // Обновляем состояние кнопки приёма
      updateReceiveButton();
    }

    // История сигналов - кастомный список
    function addSignalToHistory(binary, result, creepy) {
      const now = new Date();
      let dtStr = now.toLocaleDateString('ru-RU') + ' ' + now.toLocaleTimeString('ru-RU');
      if (creepy) {
        dtStr = zalgo(dtStr, 7);
      }
      const id = signalHistory.length + 1;
      signalHistory.push({id, datetime: dtStr, binary, result, creepy});
      renderHistory();
    }

    function renderHistory() {
      historyList.innerHTML = '';
      signalHistory.forEach(signal => {
        const div = document.createElement('div');
        div.className = 'option';
        div.textContent = `${signal.id}. ${signal.datetime}`;
        div.dataset.id = signal.id;
        div.addEventListener('click', () => {
          // Снимаем выделение со всех
          historyList.querySelectorAll('.option').forEach(opt => opt.classList.remove('selected'));
          // Выделяем текущий
          div.classList.add('selected');
          // Отображаем данные сигнала
          showSignal(signal.id);
        });
        historyList.appendChild(div);
      });
    }

    function showSignal(id) {
      const signal = signalHistory.find(s => s.id === id);
      if (!signal) return;
      statusText.value = 'Сигнал из истории.';
      binaryText.value = signal.binary;
      resultText.value = signal.result;
      decryptBtn.disabled = true; // Блокируем кнопку расшифровки при просмотре истории
      if (signal.creepy) {
        resultText.style.color = 'var(--creepy-red)';
      } else {
        resultText.style.color = 'var(--soft-yellow)';
      }
    }

    deleteButton.addEventListener('click', () => {
      const selected = historyList.querySelector('.option.selected');
      if (!selected) return;
      const selectedId = parseInt(selected.dataset.id);
      signalHistory = signalHistory.filter(s => s.id !== selectedId);
      // Перенумеруем id
      signalHistory.forEach((s, i) => s.id = i + 1);
      renderHistory();
      statusText.value = 'Система готова к работе.';
      binaryText.value = '';
      resultText.value = '';
      decryptBtn.disabled = true;
    });

    // Управление листком бумаги
    function initPaperControls() {
      // Начальная позиция листка
      paper.style.left = '50%';
      paper.style.top = '50%';
      paper.style.transform = 'translate(-50%, -50%)';
      
      // Обработчики событий для перемещения
      paper.addEventListener('mousedown', startDrag);
      paper.addEventListener('touchstart', startDragTouch);
      
      document.addEventListener('mousemove', drag);
      document.addEventListener('touchmove', dragTouch);
      
      document.addEventListener('mouseup', stopDrag);
      document.addEventListener('touchend', stopDrag);
      
      // Обработчик для вращения с Shift
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Shift') {
          isRotating = true;
          paper.style.cursor = 'grabbing';
        }
      });
      
      document.addEventListener('keyup', (e) => {
        if (e.key === 'Shift') {
          isRotating = false;
          paper.style.cursor = isDragging ? 'grabbing' : 'grab';
        }
      });
    }

    function startDrag(e) {
      isDragging = true;
      startX = e.clientX;
      startY = e.clientY;
      initialX = parseInt(paper.style.left) || 0;
      initialY = parseInt(paper.style.top) || 0;
      paper.style.cursor = 'grabbing';
      e.preventDefault();
    }

    function startDragTouch(e) {
      isDragging = true;
      startX = e.touches[0].clientX;
      startY = e.touches[0].clientY;
      initialX = parseInt(paper.style.left) || 0;
      initialY = parseInt(paper.style.top) || 0;
      e.preventDefault();
    }

    function drag(e) {
      if (!isDragging) return;
      
      const currentX = e.clientX;
      const currentY = e.clientY;
      
      if (isRotating) {
        // Вращение
        const deltaX = currentX - startX;
        const deltaY = currentY - startY;
        rotationX += deltaY * 0.5;
        rotationY += deltaX * 0.5;
        
        paper.style.transform = `translate(-50%, -50%) rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;
      } else {
        // Перемещение
        const deltaX = currentX - startX;
        const deltaY = currentY - startY;
        
        paper.style.left = `${initialX + deltaX}px`;
        paper.style.top = `${initialY + deltaY}px`;
        paper.style.transform = `translate(0, 0) rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;
      }
      
      startX = currentX;
      startY = currentY;
    }

    function dragTouch(e) {
      if (!isDragging) return;
      
      const currentX = e.touches[0].clientX;
      const currentY = e.touches[0].clientY;
      
      if (isRotating) {
        // Вращение
        const deltaX = currentX - startX;
        const deltaY = currentY - startY;
        rotationX += deltaY * 0.5;
        rotationY += deltaX * 0.5;
        
        paper.style.transform = `translate(-50%, -50%) rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;
      } else {
        // Перемещение
        const deltaX = currentX - startX;
        const deltaY = currentY - startY;
        
        paper.style.left = `${initialX + deltaX}px`;
        paper.style.top = `${initialY + deltaY}px`;
        paper.style.transform = `translate(0, 0) rotateX(${rotationX}deg) rotateY(${rotationY}deg)`;
      }
      
      startX = currentX;
      startY = currentY;
      e.preventDefault();
    }

    function stopDrag() {
      isDragging = false;
      paper.style.cursor = 'grab';
    }

    // Переходы между сценами
    async function transitionToDesk() {
      // Останавливаем ambient звук
      ambientAudio.pause();
      
      // Показываем оверлей перехода
      transitionOverlay.style.display = 'flex';
      transitionOverlay.textContent = 'ПЕРЕХОД К СТОЛУ...';
      transitionOverlay.classList.add('eye-close');
      
      // Воспроизводим звук перехода
      transitionAudio.currentTime = 0;
      transitionAudio.play();
      
      // Анимация поднятия экрана
      document.body.classList.add('screen-move-up');
      
      // Ждём завершения анимации
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Скрываем основной интерфейс
      document.getElementById('left-panel').style.display = 'none';
      document.getElementById('right-panel').style.display = 'none';
      
      // Показываем сцену стола
      deskScene.style.display = 'flex';
      deskScene.classList.add('desk-move-up');
      
      // Анимация открытия глаз
      transitionOverlay.textContent = '';
      transitionOverlay.classList.remove('eye-close');
      transitionOverlay.classList.add('eye-open');
      
      // Ждём завершения анимации
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Скрываем оверлей
      transitionOverlay.style.display = 'none';
      transitionOverlay.classList.remove('eye-open');
      
      // Обновляем содержимое листка, если выбран сигнал из истории
      updatePaperContent();
    }

    async function transitionToComputer() {
      // Показываем оверлей перехода
      transitionOverlay.style.display = 'flex';
      transitionOverlay.textContent = 'ВОЗВРАТ К КОМПЬЮТЕРУ...';
      transitionOverlay.classList.add('eye-close');
      
      // Воспроизводим звук перехода
      transitionAudio.currentTime = 0;
      transitionAudio.play();
      
      // Анимация опускания стола
      deskScene.classList.add('desk-move-down');
      
      // Ждём завершения анимации
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Скрываем сцену стола
      deskScene.style.display = 'none';
      deskScene.classList.remove('desk-move-up', 'desk-move-down');
      
      // Показываем основной интерфейс
      document.getElementById('left-panel').style.display = 'flex';
      document.getElementById('right-panel').style.display = 'flex';
      document.body.classList.remove('screen-move-up');
      document.body.classList.add('screen-move-down');
      
      // Анимация открытия глаз
      transitionOverlay.textContent = '';
      transitionOverlay.classList.remove('eye-close');
      transitionOverlay.classList.add('eye-open');
      
      // Ждём завершения анимации
      await new Promise(resolve => setTimeout(resolve, 2000));
      
      // Скрываем оверлей
      transitionOverlay.style.display = 'none';
      transitionOverlay.classList.remove('eye-open');
      document.body.classList.remove('screen-move-down');
      
      // Возобновляем ambient звук
      if (ambientStarted) {
        ambientAudio.play();
      }
    }

    function updatePaperContent() {
      const selected = historyList.querySelector('.option.selected');
      if (selected) {
        const signalId = parseInt(selected.dataset.id);
        const signal = signalHistory.find(s => s.id === signalId);
        if (signal) {
          const date = new Date();
          paperDate.textContent = date.toLocaleDateString('ru-RU');
          paperSignalType.textContent = signal.creepy ? 'АНОМАЛЬНЫЙ' : 'НОРМАЛЬНЫЙ';
          paperMessage.textContent = signal.result;
          
          if (signal.creepy) {
            paperMessage.style.color = '#8b0000';
            paperMessage.style.fontWeight = 'bold';
          } else {
            paperMessage.style.color = '#3a2c1a';
            paperMessage.style.fontWeight = 'normal';
          }
        }
      } else {
        paperDate.textContent = new Date().toLocaleDateString('ru-RU');
        paperSignalType.textContent = 'НЕТ ДАННЫХ';
        paperMessage.textContent = 'Выберите сигнал в истории на компьютере для просмотра деталей.';
        paperMessage.style.color = '#7a6a51';
        paperMessage.style.fontWeight = 'normal';
      }
    }

    // Обработчики клавиш для переходов
    document.addEventListener('keydown', (e) => {
      // Переход к столу с компьютера (стрелка вниз)
      if (e.key === 'ArrowDown' && deskScene.style.display === 'none') {
        transitionToDesk();
      }
      // Возврат к компьютеру со стола (стрелка вверх)
      else if (e.key === 'ArrowUp' && deskScene.style.display === 'flex') {
        transitionToComputer();
      }
    });

    // Инициализация при загрузке страницы
    async function init() {
      renderTelescopes();
      updateReceiveButton();
      await loadSignals();
      updateReceiveButton();
      initPaperControls();
      
      // Добавляем подсказку об управлении переходами
      const computerHint = document.createElement('div');
      computerHint.className = 'controls-hint';
      computerHint.style.position = 'fixed';
      computerHint.style.top = '10px';
      computerHint.style.bottom = 'auto';
      computerHint.textContent = 'Нажмите ↓ для перехода к столу';
      document.body.appendChild(computerHint);
    }

    // Обработчики событий
    receiveBtn.addEventListener('click', () => {
      startAmbient();
      receiveSignal();
    });

    decryptBtn.addEventListener('click', () => {
      decryptSignal();
    });

    // Обновляем содержимое листка при выборе сигнала в истории
    historyList.addEventListener('click', () => {
      if (deskScene.style.display === 'flex') {
        updatePaperContent();
      }
    });

    // Запускаем инициализацию при загрузке страницы
    init();
  </script>
</body>
</html>
